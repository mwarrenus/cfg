#   -*- shell-script -*-

cygwin=false
darwin=false
hpux=false
linux=false
mingw=false
os400=false
case "`uname -s`" in
CYGWIN*) cygwin=true;;
Darwin*) darwin=true;;
HP-UX*) hpux=true;;
Linux*) linux=true;;
MINGW*) mingw=true;;
OS400*) os400=true;;
esac

# ansi sequence ESC[<bold>;<fore>;<back>m where
# csi = control sequence introduction, ESC-[, \e[, \033[
   csi	='\e['
  GRAY	="${csi}0;37m"
   RED	="${csi}0;31m"
YELLOW	="${csi}0;33m"
 GREEN	="${csi}0;32m"
  CYAN	="${csi}0;36m"
  BLUE	="${csi}0;34m"
OCHRE	="${csi}38;5;95m"

    BRED="${csi}1;31m"
  BGREEN="${csi}1;32m"
 BYELLOW="${csi}1;33m"
   BBLUE="${csi}1;34m"
BMAGENTA="${csi}1;35m"
   BCYAN="${csi}1;36m"
   BGRAY="${csi}1;37m"
    UNDL="${csi}4m"
   FRAME="${csi}4;53m"
    OFF	="${csi}0m"
 Y_ON_B	="${csi}8;37;44m"


### https://superuser.com/questions/39751/
#mw Skip the directory existence check during setup phase; some directories are getting created
#    if [ -d "$ARG" ] && [[ ":$PATH:" != *":$ARG:"* ]]; then
pathappend() {
  for ARG in "$@"; do
    if [ -d "$ARG" ] && [[ ":$PATH:" != *":$ARG:"* ]]; then
        PATH="${PATH:+"$PATH:"}$ARG"
    fi
  done
}

# Add $@ args to beginning of $PATH
pathprepend() {
  for ((i=$#; i>0; i--)); do
    ARG="${!i}"
    if [ -d "$ARG" ] && [[ ":$PATH:" != *":$ARG:"* ]]; then
        PATH="$ARG${PATH:+":$PATH"}"
    fi
  done
}

# simple extension of https://stackoverflow.com/questions/370047
# Delete $@ args from $PATH
pathdelete() {
    local IFS=':'
    t=($PATH)
    n=${#t[*]}
    a=()
    for ARG in "$@"; do
		for ((i=0;i<n;i++)); do
			p="${t[i]%%*"$ARG"*}"
			[ "${p}" ] && a[i]="${p}"
		done
    done

    PATH="${a[*]}"
}    

function git_color {
  local git_status="$(git status 2> /dev/null)"

  if [[ ! $git_status =~ "working tree clean" ]]; then
    echo -e $RED
  elif [[ $git_status =~ "Your branch is ahead of" ]]; then
    echo -e $YELLOW
  elif [[ $git_status =~ "nothing to commit" ]]; then
    echo -e $GREEN
  else
    echo -e $OCHRE
  fi
}

parse_git_branch() {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
}

# from https://thrysoee.dk/pushd/
cd() {
   local i MAX LEN p

   MAX=10
   LEN=${#DIRSTACK[@]}

   if [ $# -eq 0 ] || [ "$1" = "-" ]; then
      builtin cd "$@" || return 1
      pushd -n $OLDPWD > /dev/null
   else
      pushd "$@" > /dev/null || return 1
   fi

   if [ $LEN -gt 1 ]; then
      for ((i=1; i <= LEN ; i++)); do
         eval p=~$i
         if [ "$p" = "$PWD" ]; then
            popd -n +$i > /dev/null
            break
         fi
      done
   fi

   if [ $LEN -ge $MAX ]; then
      popd -n -0 > /dev/null
   fi
}



# Right side prompt experiments

# For ref. from lattice. Backslash dollar gets '#' for root.
export PS1='\[\e[0;4;37m\]\u@\h\[\e[0m\]\[$(git_color)\]$(parse_git_branch)\[\e[0m\] \[\e[37m\]\$ \[\e[1;37m\]'

# pre_exec(){
#     echo "Do something."
# }
# export PS0='$(pre_exec)\[\e[0m\]'
export PS0='\[\e[0m\]'

# pre_prompt() {
# #                                    Right   Left
#      PS1=$(printf "%${COLUMNS}s\r%s" "\w" "$PS1")
# }
# PROMPT_COMMAND=pre_prompt

# print_pre_prompt(){
# Right-aligned working directory
# https://superuser.com/questions/187455/right-align-part-of-prompt/1203400#1203400

# Create a string like:  "[ Apr 25 16:06 ]" with time in RED.
# printf -v PS1RHS "\e[0m[ \e[0;1;31m%(%b %d %H:%M)T \e[0m]" -1 # -1 is current time

# Working directory
printf -v PS1RHS "\\[${GRAY}\\w${OFF}\\]"

# Strip ANSI commands before counting length
# From: https://www.commandlinefu.com/commands/view/12043/remove-color-special-escape-ansi-codes-from-text-with-sed
PS1RHS_stripped=$(sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" <<<"$PS1RHS")

# Reference: https://en.wikipedia.org/wiki/ANSI_escape_code
# local Save='\e[s' # Save cursor position
# local Rest='\e[u' # Restore cursor to save point
Save='\e[s' # Save cursor position
Rest='\e[u' # Restore cursor to save point

# Save cursor position, jump to right hand edge, then go left N columns where
# N is the length of the printable RHS string. Print the RHS string, then
# return to the saved position and print the LHS prompt.

# Note: "\[" and "\]" are used so that bash can calculate the number of
# printed characters so that the prompt doesn't do strange things when
# editing the entered text.
# CSI n C - move cursor forward
# CSI n D - move cursor back
#mw orig PS1
# PS1="\[${Save}\e[${COLUMNS:-$(tput cols)}C\e[${#PS1RHS_stripped}D${PS1RHS}${Rest}\]${PS1}"
pwd_len(){
    if [[ "$PWD" =~ "${HOME}" ]]; then
	echo $(expr ${#PWD} - ${#HOME} + 1);
    else
	echo ${#PWD}
    fi
}
PS1="\[${Save}\e[${COLUMNS:-$(tput cols)}C\e[\$(pwd_len)D${PS1RHS}${Rest}\]${PS1}"
#debug echo "PS1=$PS1"

# }
# PROMPT_COMMAND=print_pre_prompt
