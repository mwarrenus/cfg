#   -*- shell-script -*-

cygwin=false
darwin=false
hpux=false
linux=false
mingw=false
os400=false
case "`uname -s`" in
CYGWIN*) cygwin=true;;
Darwin*) darwin=true;;
HP-UX*) hpux=true;;
Linux*) linux=true;;
MINGW*) mingw=true;;
OS400*) os400=true;;
esac

### https://superuser.com/questions/39751/
#mw Skip the directory existence check during setup phase; some directories are getting created
#    if [ -d "$ARG" ] && [[ ":$PATH:" != *":$ARG:"* ]]; then
pathappend() {
  for ARG in "$@"; do
    if [ -d "$ARG" ] && [[ ":$PATH:" != *":$ARG:"* ]]; then
        PATH="${PATH:+"$PATH:"}$ARG"
    fi
  done
}

# Add $@ args to beginning of $PATH
pathprepend() {
  for ((i=$#; i>0; i--)); do
    ARG="${!i}"
    if [ -d "$ARG" ] && [[ ":$PATH:" != *":$ARG:"* ]]; then
        PATH="$ARG${PATH:+":$PATH"}"
    fi
  done
}

# simple extension of https://stackoverflow.com/questions/370047
# Delete $@ args from $PATH
pathdelete() {
    local IFS=':'
    t=($PATH)
    n=${#t[*]}
    a=()
    for ARG in "$@"; do
		for ((i=0;i<n;i++)); do
			p="${t[i]%%*"$ARG"*}"
			[ "${p}" ] && a[i]="${p}"
		done
    done

    PATH="${a[*]}"
}    

parse_git_branch() {
  git branch 2> /dev/null | sed -e '/^[^*]/d' -e 's/* \(.*\)/ (\1)/'
}

# from https://thrysoee.dk/pushd/
cd() {
   local i MAX LEN p

   MAX=10
   LEN=${#DIRSTACK[@]}

   if [ $# -eq 0 ] || [ "$1" = "-" ]; then
      builtin cd "$@" || return 1
      pushd -n $OLDPWD > /dev/null
   else
      pushd "$@" > /dev/null || return 1
   fi

   if [ $LEN -gt 1 ]; then
      for ((i=1; i <= LEN ; i++)); do
         eval p=~$i
         if [ "$p" = "$PWD" ]; then
            popd -n +$i > /dev/null
            break
         fi
      done
   fi

   if [ $LEN -ge $MAX ]; then
      popd -n -0 > /dev/null
   fi
}



# Right side prompt experiments

# from lattice
# export PS1="\u@\h \W\[\033[32m\]\$(parse_git_branch)\[\033[00m\] $ "

# pre_prompt() {
#     #                                 Right   Left
#     PS1=$(printf "%${COLUMNS}s\r%s" "$(pwd)" "$PS1")
# }
# PROMPT_COMMAND=pre_prompt

# print_pre_prompt(){
# # Right-aligned working directory
# # https://superuser.com/questions/187455/right-align-part-of-prompt/1203400#1203400
# # Create a string like:  "[ Apr 25 16:06 ]" with time in RED.
# printf -v PS1RHS "\e[0m[ \e[0;1;31m%(%b %d %H:%M)T \e[0m]" -1 # -1 is current time

# # Strip ANSI commands before counting length
# # From: https://www.commandlinefu.com/commands/view/12043/remove-color-special-escape-ansi-codes-from-text-with-sed
# PS1RHS_stripped=$(sed "s,\x1B\[[0-9;]*[a-zA-Z],,g" <<<"$PS1RHS")

# # Reference: https://en.wikipedia.org/wiki/ANSI_escape_code
# local Save='\e[s' # Save cursor position
# local Rest='\e[u' # Restore cursor to save point

# # Save cursor position, jump to right hand edge, then go left N columns where
# # N is the length of the printable RHS string. Print the RHS string, then
# # return to the saved position and print the LHS prompt.

# # Note: "\[" and "\]" are used so that bash can calculate the number of
# # printed characters so that the prompt doesn't do strange things when
# # editing the entered text.
# PS1="\[${Save}\e[${COLUMNS:-$(tput cols)}C\e[${#PS1RHS_stripped}D${PS1RHS}${Rest}\]${PS1}"

# echo "PS1=$PS1"

# }

